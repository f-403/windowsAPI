

### 1.创建互斥体
```cpp
HANDLE first = CreateMutex(NULL, FALSE, L"WeChat");//先创建一个互斥体用于下面查找测试
//如果GetLastError() == ERROR_ALREADY_EXISTS说明程序已在运行
CloseHandle(first);//释放
```



### 2. 延迟加载DLL导入函数\
```
extern "C" __declspec(dllexport) void dll_test();

```
> 不像动态加载那样查找dll再查找函数

### 3.插入资源
```cpp
/*
1. FindResource根据资源类型与资源名称定位资源
2. SizeofResource获取资源大小，返回资源大小
3. LoadResource把资源加载进内存
4. LockResource锁定加载进内存的资源，返回指向资源起始地址的lpvoid指针
示例程序加载了一个自定义资源,类型为 "MYTEST"，它的下级目录下有资源名称， 如IDR_MYTEST
记得添加资源后要添加头文件rewsouce.h, 此头文件在你添加资源后自动生成
*/

//加载
FindResource(NULL,MAKEINTRESOURCE(IDR_MYTEST), L"MYTEST");//要用宏转换一下第二个参数
//查大小
DWORD check_size = SizeofResource(NULL, hrsrc);
//读进内存
HANDLE rhandle = LoadResource(NULL, hrsrc);
//锁定
LPVOID lresrc = LockResource(rhandle);

//--------------------------------------------------------------------
//如果要查找自已导入的dll里面的资源，就要先导入dll
HMODULE dll = LoadLibrary(L"shellcode.dll");
//之后的流程是一样的
FindResource(dll,MAKEINTRESOURCE(IDR_MYTEST), L"MYTEST");//要用宏转换一下第
//注意这里的第一个参数为导入dll后返回的HMODLE
//下面的步骤一样
```



## 4.编历所有资源

#### 4.1. LoadLibraryExW 加载DLL 
```cpp
HMODULE LoadLibraryExW(
  LPCWSTR lpLibFileName,  // DLL路径
  HANDLE  hFile,          // 保留参数，设为NULL
  DWORD   dwFlags         // 加载标志
);
//dwflags的类型可以查看文档
https://learn.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa
```
### 4.2. EnumResourceTypesW 枚举DLL中所有资源类型（如RT_BITMAP、RT_RCDATA等）
```cpp
BOOL EnumResourceTypesW(
  HMODULE          hModule,       // DLL模块句柄
  ENUMRESTYPEPROCW lpEnumFunc,    // 回调函数指针
  LONG_PTR         lParam         // 用户自定义参数
);
//回调函数原型:
typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(
    HMODULE  hModule,  // 包含资源的模块句柄（DLL或EXE）
    LPWSTR  lpType,   // 资源类型（字符串或整数ID）
    LONG_PTR lParam    // 用户自定义参数
);
hModule //EnumResourceTypesW一样
LPTSTR //要为其枚举类型的资源的类型。此参数可以 MAKEINTRESOURCE(ID),跟FindResource中 的第二个参数一样
LONG_PTR //传递给 EnumResourceTypes 或 EnumResourceTypesEx 函数的应用程序定义参数
```
### 4.3. EnumResourceNames 枚举指定类型下的所有资源名称
```cpp
BOOL EnumResourceNames(
  HMODULE          hModule,      // DLL模块句柄
  LPCWSTR          lpType,       // 资源类型
  ENUMRESNAMEPROCW lpEnumFunc,   // 回调函数指针
  LONG_PTR         lParam        // 用户自定义参数
);

//回调函数原型:
BOOL CALLBACK EnumResNameProcW(
  HMODULE hModule,  // DLL模块句柄
  LPCWSTR lpType,   // 资源类型
  LPWSTR  lpName,   // 资源名称（可能是字符串或整数ID）
  LONG_PTR lParam   // 用户自定义参数
);

```

### 4.4.EnumResourceLanguages 枚举资源的语言ID（如英语-1033、中文-2052）
```c
BOOL EnumResourceLanguagesW(
  HMODULE          hModule,      // DLL模块句柄
  LPCWSTR          lpType,       // 资源类型
  LPCWSTR          lpName,       // 资源名称
  ENUMRESLANGPROCW lpEnumFunc,   // 回调函数指针
  LONG_PTR         lParam        // 用户自定义参数
);

//回调函数原型
BOOL CALLBACK EnumResLangProc(
  HMODULE hModule,  // DLL模块句柄
  LPCWSTR lpType,   // 资源类型
  LPCWSTR lpName,   // 资源名称
  WORD    wLanguage,// 语言ID（LCID）
  LONG_PTR lParam   // 用户自定义参数
);
```
### 5.自定义回调函数实现
 #### 5.1. 资源类型枚举回调
```cpp
BOOL CALLBACK EnumResTypeProc(
    HMODULE hModule, 
    LPCWSTR lpType, 
    LONG_PTR lParam) {
    
    // 判断资源类型是字符串还是整数ID
    if (IS_INTRESOURCE(lpType)) {
        wprintf(L"资源类型ID: %d\n", (int)lpType);
    } else {
        wprintf(L"资源类型名: %s\n", lpType);
    }
    
    // 继续枚举该类型下的资源名称
    EnumResourceNames(hModule, lpType, EnumResNameProc, lParam);
    return TRUE;
}
```
### 5.2. 资源名称枚举回调
```cpp
BOOL CALLBACK EnumResNameProc(
    HMODULE hModule, 
    LPCWSTR lpType, 
    LPWSTR lpName, 
    LONG_PTR lParam) {
    
    // 判断资源名称是字符串还是整数ID
    if (IS_INTRESOURCE(lpName)) {
        wprintf(L"  资源ID: %d\n", (int)lpName);
    } else {
        wprintf(L"  资源名称: %s\n", lpName);
    }
    
    // 继续枚举该资源的语言版本
    EnumResourceLanguages(hModule, lpType, lpName, EnumResLangProc, lParam);
    return TRUE;
}
```

### 5.3. 语言ID枚举回调
```cpp
BOOL CALLBACK EnumResLangProc(
    HMODULE hModule, 
    LPCWSTR lpType, 
    LPCWSTR lpName, 
    WORD wLanguage, 
    LONG_PTR lParam) {
    
    wprintf(L"      语言ID: 0x%04X\n", wLanguage);
    return TRUE;
}

```


## 5.调用方法
### 5.0. 资源枚举函数与回调函数的对应关系
```bash
EnumResourceTypesW	ENUMRESTYPEPROCW	处理每个资源类型（如 RT_BITMAP、RT_RCDATA）
EnumResourceNamesW	ENUMRESNAMEPROCW	处理指定类型下的资源名称（如资源ID或字符串名）
EnumResourceLanguagesW	ENUMRESLANGPROCW	处理指定资源的语言ID（如 0x0409 英语）
```
5.1：定义三个回调函数
```cpp
// 1. 处理资源类型
BOOL CALLBACK EnumResTypeProc(HMODULE hModule, LPCWSTR lpType, LONG_PTR lParam) {
    if (IS_INTRESOURCE(lpType)) {
        wprintf(L"资源类型ID: %d\n", (int)lpType);
    } else {
        wprintf(L"资源类型名: %s\n", lpType);
    }
    
    // 继续枚举该类型下的资源名称
    EnumResourceNamesW(hModule, lpType, EnumResNameProc, lParam);
    return TRUE;
}

// 2. 处理资源名称
BOOL CALLBACK EnumResNameProc(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, LONG_PTR lParam) {
    if (IS_INTRESOURCE(lpName)) {
        wprintf(L"  资源ID: %d\n", (int)lpName);
    } else {
        wprintf(L"  资源名称: %s\n", lpName);
    }
    
    // 继续枚举该资源的语言版本
    EnumResourceLanguagesW(hModule, lpType, lpName, EnumResLangProc, lParam);
    return TRUE;
}

// 3. 处理语言ID
BOOL CALLBACK EnumResLangProc(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLang, LONG_PTR lParam) {
    wprintf(L"      语言ID: 0x%04X\n", wLang);
    return TRUE;
}
```

### 5.2：从顶层开始枚举
```cpp
HMODULE hModule = LoadLibraryExW(L"test.dll", NULL, 
    LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);

if (hModule) {
    // 启动枚举流程：类型 → 名称 → 语言
    EnumResourceTypesW(hModule, EnumResTypeProc, 0);
    FreeLibrary(hModule);
}
```

### 5.3. 关键行为说明
```cpp
/*调用 EnumResourceTypesW 会触发 EnumResTypeProc 回调。
在 EnumResTypeProc 中调用 EnumResourceNamesW，进而触发 EnumResNameProc。
在 EnumResNameProc 中调用 EnumResourceLanguagesW，最终触发 EnumResLangProc。
在任何回调中返回 FALSE 会立即停止当前层级的枚举：
*/
BOOL CALLBACK EnumResTypeProc(HMODULE, LPCWSTR, LONG_PTR) {
    static int count = 0;
    if (++count > 5) return FALSE; // 只枚举5种类型后停止
    return TRUE;
}
```

## 6.字符串转换函数 `strtol`

```c++
	/*
	long int strtol(
    const char* str,   // 要转换的字符串（如 "73"）
    char** endptr,     // 指向停止转换位置的指针（传nullptr表示不处理）
    int base           // 进制（传16表示按16进制解析）
);
	*/
//把字符形式的16进制转为int再转为char, 实现把16进制字符串转为ASCII码
std::string text;
const char* data = "7368656c6c636f646520696e2068657265";
for (int i = 0; i < strlen(data); i = i + 2) {
    char swap_data[2] = { data[i], data[i + 1]};
    text += char( strtol(swap_data, nullptr, 16));
}
    ```