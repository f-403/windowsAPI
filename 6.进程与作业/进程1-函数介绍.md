# Windows 进程与控制台相关 API 详细汇总

## 目录

- [1. CreateProcess](#1-createprocess)
- [2. GetCurrentProcess / GetCurrentProcessId](#2-getcurrentprocess--getcurrentprocessid)
- [3. OpenProcess](#3-openprocess)
- [4. DuplicateHandle](#4-duplicatehandle)
- [5. GetExitCodeProcess](#5-getexitcodeprocess)
- [6. TerminateProcess](#6-terminateprocess)
- [7. WaitForSingleObject / WaitForMultipleObjects](#7-waitforsingleobject--waitformultipleobjects)
- [8. GetEnvironmentVariable / SetEnvironmentVariable](#8-getenvironmentvariable--setenvironmentvariable)
- [9. GenerateConsoleCtrlEvent](#9-generateconsolectrlevent)
- [10. 控制台信号处理示例](#10-控制台信号处理示例)

---

## 1. CreateProcess

**功能**：创建一个新进程及其主线程，并可指定启动信息和创建选项。

```cpp
BOOL CreateProcessW(
  LPCWSTR               lpApplicationName,
  LPWSTR                lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL                  bInheritHandles,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCWSTR               lpCurrentDirectory,
  LPSTARTUPINFOW        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
```

* `lpApplicationName`：可执行程序路径，或为 `NULL`。

* `lpCommandLine`：命令行参数，必须是可修改的字符数组（`wchar_t[]`），Windows会修改此字符串。

* `bInheritHandles`：是否允许子进程继承父进程句柄。

* `dwCreationFlags`：进程创建标志，例如：
  
  * `CREATE_NO_WINDOW`：无控制台窗口，后台运行。
  * `CREATE_NEW_PROCESS_GROUP`：新建进程组，用于信号传递。

* `lpStartupInfo`：结构体，指定窗口显示、标准输入输出等。

* `lpProcessInformation`：返回新进程和主线程句柄及ID。

[MSDN文档](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw)

### 示例：创建有控制台的子进程，并等待其结束

```cpp
#include <windows.h>
#include <iostream>

int main() {
    STARTUPINFO si{};
    PROCESS_INFORMATION pi{};
    si.cb = sizeof(si);

    // 注意，命令行参数必须是可修改数组
    wchar_t cmdLine[] = L"notepad.exe";

    BOOL success = CreateProcessW(
        NULL,           // lpApplicationName
        cmdLine,        // lpCommandLine (必须可写)
        NULL,           // lpProcessAttributes
        NULL,           // lpThreadAttributes
        FALSE,          // bInheritHandles
        CREATE_NEW_CONSOLE,// dwCreationFlags（默认有窗口）
        NULL,           // lpEnvironment
        NULL,           // lpCurrentDirectory
        &si,
        &pi
    );

    if (!success) {
        std::wcout << L"创建进程失败，错误码：" << GetLastError() << std::endl;
        return 1;
    }

    std::wcout << L"进程已创建，PID：" << pi.dwProcessId << std::endl;

    // 等待进程结束
    WaitForSingleObject(pi.hProcess, INFINITE);

    DWORD exitCode;
    if (GetExitCodeProcess(pi.hProcess, &exitCode)) {
        std::wcout << L"进程退出码：" << exitCode << std::endl;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    return 0;
}
```

### 示例：无窗口后台运行子进程

```cpp
STARTUPINFO si{};
PROCESS_INFORMATION pi{};
si.cb = sizeof(si);
wchar_t cmdLine[] = L"child.exe";

BOOL success = CreateProcessW(
    NULL,
    cmdLine,
    NULL,
    NULL,
    FALSE,
    CREATE_NO_WINDOW,
    NULL,
    NULL,
    &si,
    &pi
);

if (success) {
    std::wcout << L"后台进程已创建，PID：" << pi.dwProcessId << std::endl;
} else {
    std::wcout << L"创建失败，错误：" << GetLastError() << std::endl;
}

// 关闭句柄不会导致子进程结束
CloseHandle(pi.hThread);
CloseHandle(pi.hProcess);  
//当第一个参数为NULL时， 第二个参数会折分出程序名+参数
//当第一个参数不为NULL时， 第二个参数是传递到程序的参数
//所以一般只写第二个参数就行了，第一个参数留空。
```

---

## 2. GetCurrentProcess / GetCurrentProcessId

* `GetCurrentProcess()` 返回当前进程的伪句柄，无需关闭。
* `GetCurrentProcessId()` 返回当前进程ID。

[GetCurrentProcess MSDN](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocess)
[GetCurrentProcessId MSDN](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentprocessid)

### 示例

```cpp
#include <windows.h>
#include <iostream>

int main() {
    HANDLE hProcess = GetCurrentProcess();
    DWORD pid = GetCurrentProcessId();

    std::wcout << L"当前进程伪句柄：" << hProcess << std::endl;
    std::wcout << L"当前进程ID：" << pid << std::endl;
    return 0;
}
```

---

## 3. OpenProcess

打开指定PID的进程句柄，需指定访问权限。

```cpp
HANDLE OpenProcess(
  DWORD dwDesiredAccess,
  BOOL  bInheritHandle,
  DWORD dwProcessId
);
```

* `dwDesiredAccess`：常用权限如 `PROCESS_ALL_ACCESS`, `PROCESS_QUERY_INFORMATION`。
* `bInheritHandle`：是否允许继承。
* `dwProcessId`：目标进程ID。

[MSDN文档](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess)

### 示例：打开进程并查询退出码

```cpp
DWORD targetPid = 1234; // 目标PID
HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_TERMINATE, FALSE, targetPid);
if (hProcess == NULL) {
    std::wcout << L"打开进程失败，错误：" << GetLastError() << std::endl;
    return 1;
}

DWORD exitCode;
if (GetExitCodeProcess(hProcess, &exitCode)) {
    if (exitCode == STILL_ACTIVE) {
        std::wcout << L"进程仍在运行\n";
    } else {
        std::wcout << L"进程已退出，退出码：" << exitCode << std::endl;
    }
}

CloseHandle(hProcess);
```

---

## 4. DuplicateHandle

复制句柄，可跨进程复制，并设置权限和继承属性。

```cpp
BOOL DuplicateHandle(
  HANDLE hSourceProcessHandle,
  HANDLE hSourceHandle,
  HANDLE hTargetProcessHandle,
  LPHANDLE lpTargetHandle,
  DWORD  dwDesiredAccess,
  BOOL   bInheritHandle,
  DWORD  dwOptions
);
```

* `dwDesiredAccess`：新句柄访问权限，如 `PROCESS_ALL_ACCESS`。
* `dwOptions`：复制标志，如 `DUPLICATE_SAME_ACCESS`。

[MSDN文档](https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-duplicatehandle)

### 示例：复制当前进程的标准输出句柄到另一个进程

```cpp
HANDLE hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, targetPid);
HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
HANDLE hDuplicate = NULL;

BOOL success = DuplicateHandle(
    GetCurrentProcess(),
    hStdOut,
    hTargetProcess,
    &hDuplicate,
    PROCESS_ALL_ACCESS,
    FALSE,
    DUPLICATE_SAME_ACCESS
);

if (success) {
    std::wcout << L"句柄复制成功\n";
    CloseHandle(hDuplicate);
} else {
    std::wcout << L"复制失败，错误：" << GetLastError() << std::endl;
}

CloseHandle(hTargetProcess);
```

**通过某种通信方式把 `hDuplicate` 传给目标进程**：

- 命令行参数

- 管道/共享内存

- RPC

- 远程线程注入

---

## 5. GetExitCodeProcess

获取指定进程的退出码。

```cpp
BOOL GetExitCodeProcess(
  HANDLE  hProcess,
  LPDWORD lpExitCode
);
```

* 如果进程未退出，返回码是 `STILL_ACTIVE`（259）。

[MSDN文档](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess)

---

## 6. TerminateProcess

终止指定进程。

```cpp
BOOL TerminateProcess(
  HANDLE hProcess,
  UINT   uExitCode
);
```

* 使用该函数会强制结束进程，可能导致资源未释放。

[MSDN文档](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess)

### 示例：终止某进程

```cpp
HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
if (hProcess) {
    if (TerminateProcess(hProcess, 1)) {
        std::wcout << L"进程终止成功\n";
    } else {
        std::wcout << L"终止失败，错误：" << GetLastError() << std::endl;
    }
    CloseHandle(hProcess);
}
```

---

## 7. WaitForSingleObject / WaitForMultipleObjects

等待对象变为信号状态，常用来等待进程或线程结束。

```cpp
DWORD WaitForSingleObject(
  HANDLE hHandle,
  DWORD  dwMilliseconds
);

DWORD WaitForMultipleObjects(
  DWORD  nCount,
  const HANDLE *lpHandles,
  BOOL   bWaitAll,
  DWORD  dwMilliseconds
);
```

[MSDN文档](https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject)

---

## 8. GetEnvironmentVariable / SetEnvironmentVariable

获取和设置环境变量。

```cpp
DWORD GetEnvironmentVariable(
  LPCWSTR lpName,
  LPWSTR  lpBuffer,
  DWORD   nSize
);

BOOL SetEnvironmentVariable(
  LPCWSTR lpName,
  LPCWSTR lpValue
);
```

### 常用环境变量示例

| 环境变量名         | 说明               | 示例值                                |
| ------------- | ---------------- | ---------------------------------- |
| `SystemRoot`  | Windows 安装目录     | `C:\Windows`                       |
| `windir`      | Windows 目录（兼容变量） | `C:\Windows`                       |
| `TEMP`        | 临时目录             | `C:\Users\User\AppData\Local\Temp` |
| `USERNAME`    | 当前用户             | `formylucklife`                    |
| `USERPROFILE` | 当前用户主目录          | `C:\Users\formylucklife`           |
| `COMSPEC`     | 命令解释器路径          | `C:\Windows\System32\cmd.exe`      |

### 示例：获取并设置环境变量

```cpp
WCHAR buffer[1024] = {0};
DWORD ret = GetEnvironmentVariable(L"TEMP", buffer, 1024);
if (ret > 0 && ret < 1024) {
    std::wcout << L"TEMP目录: " << buffer << std::endl;
} else {
    std::wcout << L"读取环境变量失败或缓冲区不足\n";
}

BOOL setResult = SetEnvironmentVariable(L"MY_VAR", L"TestValue");
if (setResult) {
    std::wcout << L"环境变量设置成功\n";
} else {
    std::wcout << L"环境变量设置失败，错误码：" << GetLastError() << std::endl;
}
```

---

## 9. GenerateConsoleCtrlEvent

向进程组发送控制台事件（如 CTRL+C）。

```cpp
BOOL GenerateConsoleCtrlEvent(
  DWORD dwCtrlEvent,
  DWORD dwProcessGroupId
);
```

* 只对指定进程组发送，`dwProcessGroupId` 是创建进程时指定的进程组ID。
* 必须先用 `CREATE_NEW_PROCESS_GROUP` 标志创建进程。

[MSDN文档](https://learn.microsoft.com/en-us/windows/console/generateconsolectrlevent)

### 示例：创建进程并向其发送 CTRL+C 信号

```cpp
STARTUPINFO si{};
PROCESS_INFORMATION pi{};
si.cb = sizeof(si);

wchar_t cmdLine[] = L"child.exe";

BOOL success = CreateProcessW(
    NULL,
    cmdLine,
    NULL,
    NULL,
    TRUE,
    CREATE_NEW_PROCESS_GROUP,
    NULL,
    NULL,
    &si,
    &pi
);

if (!success) {
    std::wcout << L"创建进程失败，错误：" << GetLastError() << std::endl;
    return 1;
}

// 等待3秒后发送 CTRL+C
Sleep(3000);

if (GenerateConsoleCtrlEvent(CTRL_C_EVENT, pi.dwProcessId)) {
    std::wcout << L"CTRL+C 信号发送成功\n";
} else {
    std::wcout << L"信号发送失败，错误：" << GetLastError() << std::endl;
}

// 等待子进程结束
WaitForSingleObject(pi.hProcess, INFINITE);

CloseHandle(pi.hThread);
CloseHandle(pi.hProcess);
```

---

> 注意， 如果你在另一个进程中发送信号， 要调用GenerateConsoleCtrlEvent函数， 而别一个函数要调用SetConsoleCtrlHandler处理回调函数并处理。

## 10. 控制台信号处理示例

在进程中捕获并处理 CTRL+C 和 CTRL+BREAK 信号。

```cpp
#include <windows.h>
#include <iostream>

BOOL WINAPI CtrlHandler(DWORD dwCtrlType)
{
    switch (dwCtrlType)
    {
    case CTRL_C_EVENT:
        std::cout << "收到 CTRL+C 信号\n";
        return TRUE;  // 阻止信号进一步传递
    case CTRL_BREAK_EVENT:
        std::cout << "收到 CTRL+BREAK 信号\n";
        return TRUE;
    default:
        return FALSE; // 传递给下一个处理器
    }
}

int main()
{
    if (!SetConsoleCtrlHandler(CtrlHandler, TRUE))
    {
        std::cerr << "注册信号处理函数失败\n";
        return 1;
    }

    std::cout << "等待 CTRL+C 或 CTRL+BREAK 信号...\n";

    while (true) {
        Sleep(1000);
    }

    return 0;
}
```

---
