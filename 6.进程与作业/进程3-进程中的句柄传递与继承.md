# å¸¦ç»§æ‰¿å¥æŸ„çš„ä»£ç 

```cpp
// è¿›ç¨‹ç»§æ‰¿çˆ¶è¿›ç¨‹çš„å¥æŸ„.cpp : æ­¤æ–‡ä»¶åŒ…å« "main" å‡½æ•°ã€‚ç¨‹åºæ‰§è¡Œå°†åœ¨æ­¤å¤„å¼€å§‹å¹¶ç»“æŸã€‚
//

#include <iostream>
#include <Windows.h>
#include <string>
int main()
{
    SECURITY_ATTRIBUTES sa{};
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
    sa.nLength = sizeof(sa);
    HANDLE f = CreateFileA("1.TXT", GENERIC_ALL, 0, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    PROCESS_INFORMATION pf{};
    STARTUPINFO st{};
    st.cb = sizeof(st);
    std::wstring cmd = std::wstring(L"1.exe ") + std::to_wstring((uintptr_t)f);
    std::cout << "å½“å‰å¥æŸ„å€¼ä¸º:" << f << std::endl;
    int check = CreateProcess(NULL, &cmd[0], NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &st, &pf);
    if (check == FALSE) {
        std::cout << "è°ƒç”¨å¤±è´¥" << std::endl;
        return 0;
    }
    //å¸¦Wç‰ˆæœ¬èƒ½ä¼ å¸¸é‡ï¼Œ Aç‰ˆæœ¬è¦ç”¨char []å¯ä¿®æ”¹çš„æ•°ç»„å½¢å¼
    WaitForSingleObject(pf.hProcess, -1);


}
```

# ç”¨äºæ¥æ”¶çˆ¶è¿›ç¨‹çš„å¥æŸ„

```cpp
#include <Windows.h>
#include <iostream>

int main(int argc, char* argv[]) {


    if (argc < 2) {
        std::cerr << "use: ç¨‹åº.exe å¥æŸ„" << std::endl;
        system("pause");
        return 0;
    }
    //åˆ©ç”¨æ ‡å‡†Cå‡½æ•°è¯»å–å‚æ•°
    char* check_char = nullptr;
    errno = 0;//åˆå§‹åŒ–å†…ç½®å˜é‡
    ULONGLONG get_ulonglong = strtoull(argv[1], &check_char, 0);
    //æ•°å­—è½¬æŒ‡é’ˆå†è½¬ä¸ºHANDLE
    HANDLE get_h = HANDLE( uintptr_t(get_ulonglong));

    if (errno == ERANGE) {
        std::cout << "è½¬æ¢å‡ºé”™" << std::endl;
        system("pause");
        return 0;
    }
    if (*check_char != '\0') {
        std::cout << "å«æœ‰å­—ç¬¦ï¼Œ è½¬æ¢å¯èƒ½ä¸æ­£ç¡®" << std::endl;
        system("pause");
        return 0;
    }

    std::cout << "è·å–åˆ°çš„å¥æŸ„ä¸º: " << std::hex << get_h<< std::endl;
    //å†™æ•°æ®
    DWORD write_bytes{};
    WriteFile(get_h, u8"è¿™æ˜¯å­è¿›ç¨‹å†™å…¥çš„æ•°æ®",strlen(u8"è¿™æ˜¯å­è¿›ç¨‹å†™å…¥çš„æ•°æ®"),&write_bytes,NULL);//æ³¨æ„ç¼–ç 
    //strlenè¿”å›å­—èŠ‚æ•°ï¼Œ ä¸å«9ï¼Œ è€Œsizeofå«0
    //const wchar_t* wdata = L"è¿™æ˜¯å­è¿›ç¨‹å†™å…¥çš„æ•°æ®";
    //DWORD bytesToWrite = (DWORD)(wcslen(wdata) * sizeof(wchar_t)); // å®½å­—ç¬¦å­—èŠ‚æ•°
    //
    std::cout << "å†™å…¥äº†:" << write_bytes << " å­—èŠ‚" << std::endl;

    system("pause");
    return 0;
}
```


# Windows æ–‡ä»¶å¥æŸ„ä¼ é€’æ–¹æ³•è¯´æ˜

## ğŸ“‘ ç›®å½•
1. [æ¦‚è¿°](#æ¦‚è¿°)  
2. [æ–¹æ³•ä¸€ï¼šå¥æŸ„ç»§æ‰¿](#æ–¹æ³•ä¸€å¥æŸ„ç»§æ‰¿)  
   - [æ­¥éª¤](#æ­¥éª¤)  
   - [ç¤ºä¾‹ä»£ç ](#ç¤ºä¾‹ä»£ç )  
3. [æ–¹æ³•äºŒï¼šåŠ¨æ€å¥æŸ„ä¼ é€’](#æ–¹æ³•äºŒåŠ¨æ€å¥æŸ„ä¼ é€’)  
   - [æ–¹æ³• 2aï¼šDuplicateHandle + CreateRemoteThread + å¯¼å‡ºå‡½æ•°](#æ–¹æ³•-2a-duplicatehandle--createremotethread--å¯¼å‡ºå‡½æ•°)  
   - [æ–¹æ³• 2bï¼šçˆ¶å­è¿›ç¨‹å‚æ•°ä¼ é€’å¥æŸ„](#æ–¹æ³•-2b-çˆ¶å­è¿›ç¨‹å‚æ•°ä¼ é€’å¥æŸ„)  
4. [æ€»ç»“](#æ€»ç»“)  

---

## æ¦‚è¿°
åœ¨ Windows ä¸‹ï¼Œçˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹ä¹‹é—´å…±äº«æ–‡ä»¶å¥æŸ„çš„ä¸»è¦æ–¹æ³•æœ‰ä¸¤ç±»ï¼š  

1. **ç»§æ‰¿å¥æŸ„**ï¼ˆCreateProcess + bInheritHandlesï¼‰  
2. **åŠ¨æ€å¥æŸ„ä¼ é€’**  
   - æ–¹æ³• 2aï¼šé€šè¿‡ `DuplicateHandle + CreateRemoteThread` åœ¨ç›®æ ‡è¿›ç¨‹æ‰§è¡Œå¯¼å‡ºå‡½æ•°æ“ä½œå¥æŸ„  
   - æ–¹æ³• 2bï¼šå°†å¥æŸ„ä½œä¸ºå‚æ•°ä¼ é€’ç»™å­è¿›ç¨‹  

---

## æ–¹æ³•ä¸€ï¼šå¥æŸ„ç»§æ‰¿

### æ­¥éª¤

1. **åˆ›å»ºå¯ç»§æ‰¿çš„æ–‡ä»¶å¥æŸ„**
```cpp
SECURITY_ATTRIBUTES sa = {};
sa.nLength = sizeof(sa);
sa.bInheritHandle = TRUE;  // å…è®¸å­è¿›ç¨‹ç»§æ‰¿
sa.lpSecurityDescriptor = NULL;

HANDLE hFile = CreateFile(
    L"test.txt",
    GENERIC_WRITE,
    0,
    &sa,
    CREATE_ALWAYS,
    FILE_ATTRIBUTE_NORMAL,
    NULL
);
```

2. **é…ç½® STARTUPINFOï¼ˆæ ‡å‡† I/Oï¼‰**
```cpp
STARTUPINFO si = {0};
si.cb = sizeof(si);
si.dwFlags = STARTF_USESTDHANDLES;
si.hStdOutput = hFile;
si.hStdError  = hFile;
si.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);
```

3. **åˆ›å»ºå­è¿›ç¨‹å¹¶ç»§æ‰¿å¥æŸ„**
```cpp
PROCESS_INFORMATION pi = {};
BOOL ok = CreateProcess(
    L"child.exe",
    NULL,
    NULL, NULL,
    TRUE,   // bInheritHandles = TRUE
    0,
    NULL, NULL,
    &si, &pi
);
```

---

### ç¤ºä¾‹ä»£ç 

#### çˆ¶è¿›ç¨‹
```cpp
#include <windows.h>
#include <iostream>

int main() {
    SECURITY_ATTRIBUTES sa = {};
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;

    HANDLE hFile = CreateFile(
        L"output.txt",
        GENERIC_WRITE,
        0,
        &sa,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    STARTUPINFO si = { sizeof(si) };
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdOutput = hFile;
    si.hStdError  = hFile;
    si.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);

    PROCESS_INFORMATION pi = {};
    CreateProcess(L"child.exe", NULL, NULL, NULL,
                  TRUE, 0, NULL, NULL, &si, &pi);

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(hFile);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    std::cout << "çˆ¶è¿›ç¨‹å®Œæˆ" << std::endl;
}
```

#### å­è¿›ç¨‹
```cpp
#include <iostream>

int main() {
    std::cout << "Hello from child process via inherited handle!" << std::endl;
    return 0;
}
```

---



## æ–¹æ³• 2aï¼šDuplicateHandle + CreateRemoteThread + å¯¼å‡ºå‡½æ•°

#### 1ï¸âƒ£ å­è¿›ç¨‹ï¼ˆchild.exeï¼‰

```cpp
// child.cpp
#include <windows.h>
#include <iostream>

extern "C" __declspec(dllexport) DWORD WINAPI RemoteWrite(LPVOID lpParam) {
    HANDLE hFile = (HANDLE)lpParam;
    const char* msg = "Hello from RemoteWrite!\r\n";
    DWORD written;
    WriteFile(hFile, msg, (DWORD)strlen(msg), &written, NULL);
    std::cout << "å­è¿›ç¨‹ï¼šRemoteWrite å·²æ‰§è¡Œ" << std::endl;
    return 0;
}

int main() {
    std::cout << "å­è¿›ç¨‹å¯åŠ¨ï¼ŒPID: " << GetCurrentProcessId() << std::endl;
    std::cout << "ç­‰å¾…è¿œç¨‹çº¿ç¨‹è°ƒç”¨ RemoteWrite..." << std::endl;
    Sleep(60000); // ç­‰å¾…çˆ¶è¿›ç¨‹è°ƒç”¨
    return 0;
}
```

* æ ¸å¿ƒï¼šå¯¼å‡º `RemoteWrite(HANDLE)`ï¼Œçˆ¶è¿›ç¨‹å¯ä»¥è¿œç¨‹è°ƒç”¨ã€‚

---

#### 2ï¸âƒ£ çˆ¶è¿›ç¨‹

```cpp
#include <windows.h>
#include <iostream>
#include <tlhelp32.h>

// è¾…åŠ©ï¼šé€šè¿‡æ¨¡å—åè·å–å­è¿›ç¨‹ä¸­å¯¼å‡ºå‡½æ•°åœ°å€
LPVOID GetRemoteFuncAddress(DWORD pid, const wchar_t* moduleName, const char* funcName) {
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
    if (hSnap == INVALID_HANDLE_VALUE) return nullptr;

    MODULEENTRY32 me = {};
    me.dwSize = sizeof(me);
    if (Module32First(hSnap, &me)) {
        do {
            if (_wcsicmp(me.szModule, moduleName) == 0) {
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šå‡è®¾å­è¿›ç¨‹æ¨¡å—åŸºå€ + åç§»å·²çŸ¥
                // å®é™…å¯ç”¨å¯¼å‡ºè¡¨è§£ææˆ– DLL æ³¨å…¥æ–¹å¼è·å–
                LPVOID funcAddr = (LPBYTE)me.modBaseAddr + 0x1000; // å‡è®¾åç§»
                CloseHandle(hSnap);
                return funcAddr;
            }
        } while (Module32Next(hSnap, &me));
    }

    CloseHandle(hSnap);
    return nullptr;
}

int main() {
    DWORD targetPid = 1234; // æ›¿æ¢ä¸ºå­è¿›ç¨‹ PID
    HANDLE hTarget = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);
    if (!hTarget) {
        std::cerr << "OpenProcess failed\n";
        return 1;
    }

    // åˆ›å»ºæ–‡ä»¶å¥æŸ„
    HANDLE hFile = CreateFile(L"remote_output.txt",
                              GENERIC_WRITE, 0, NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    // å¤åˆ¶å¥æŸ„åˆ°ç›®æ ‡è¿›ç¨‹
    HANDLE hRemoteFile = NULL;
    DuplicateHandle(GetCurrentProcess(), hFile, hTarget, &hRemoteFile,
                    0, TRUE, DUPLICATE_SAME_ACCESS);

    // è·å–å­è¿›ç¨‹ RemoteWrite åœ°å€
    LPTHREAD_START_ROUTINE remoteFunc = (LPTHREAD_START_ROUTINE)
        GetRemoteFuncAddress(targetPid, L"child.exe", "RemoteWrite");

    if (!remoteFunc) {
        std::cerr << "è·å–è¿œç¨‹å‡½æ•°åœ°å€å¤±è´¥\n";
        CloseHandle(hRemoteFile);
        CloseHandle(hFile);
        CloseHandle(hTarget);
        return 1;
    }

    // åˆ›å»ºè¿œç¨‹çº¿ç¨‹æ‰§è¡Œå­è¿›ç¨‹å¯¼å‡ºå‡½æ•°
    HANDLE hThread = CreateRemoteThread(hTarget, NULL, 0,
                                        remoteFunc, hRemoteFile, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);
    CloseHandle(hRemoteFile);
    CloseHandle(hFile);
    CloseHandle(hTarget);

    std::cout << "çˆ¶è¿›ç¨‹è°ƒç”¨å®Œæˆ" << std::endl;
    return 0;
}
```

---

### ğŸ”¹ æ ¸å¿ƒè¯´æ˜

1. **DuplicateHandle**

   * çˆ¶è¿›ç¨‹åˆ›å»ºçš„æ–‡ä»¶å¥æŸ„å¤åˆ¶åˆ°å­è¿›ç¨‹ï¼Œè¿œç¨‹çº¿ç¨‹å¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚

2. **CreateRemoteThread**

   * çˆ¶è¿›ç¨‹åœ¨å­è¿›ç¨‹åˆ›å»ºçº¿ç¨‹ï¼Œè°ƒç”¨å¯¼å‡ºå‡½æ•° `RemoteWrite`ã€‚

3. **è·å–å­è¿›ç¨‹å‡½æ•°åœ°å€**

   * ç¤ºä¾‹ä¸­ç”¨ `Toolhelp32Snapshot` éå†æ¨¡å—åˆ—è¡¨ï¼Œå¾—åˆ°æ¨¡å—åŸºå€ï¼Œå†åŠ åç§»ï¼ˆç¤ºä¾‹å‡è®¾åç§»å·²çŸ¥ï¼‰ã€‚
   * å®é™…ç”Ÿäº§ç¯å¢ƒå¯ç”¨ **å¯¼å‡ºè¡¨è§£æ** æˆ– **DLL æ³¨å…¥** è·å–å‡½æ•°åœ°å€ã€‚

---


## æ–¹æ³• 2bï¼šçˆ¶å­è¿›ç¨‹å‚æ•°ä¼ é€’å¥æŸ„

#### çˆ¶è¿›ç¨‹
```cpp
#include <windows.h>
#include <iostream>
#include <sstream>

int main() {
    SECURITY_ATTRIBUTES sa = {};
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;

    HANDLE hFile = CreateFile(L"param_output.txt",
                              GENERIC_WRITE, 0, &sa,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    std::wstringstream cmdLine;
    cmdLine << L"child.exe " << (ULONG_PTR)hFile;

    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = {};

    CreateProcess(NULL,
                  (LPWSTR)cmdLine.str().c_str(),
                  NULL, NULL,
                  TRUE,   // bInheritHandles
                  0, NULL, NULL,
                  &si, &pi);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(hFile);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    std::cout << "çˆ¶è¿›ç¨‹å®Œæˆ" << std::endl;
}
```

#### å­è¿›ç¨‹
```cpp
#include <windows.h>
#include <iostream>

int wmain(int argc, wchar_t* argv[]) {
    if (argc < 2) {
        std::wcerr << L"ç¼ºå°‘å¥æŸ„å‚æ•°" << std::endl;
        return 1;
    }

    HANDLE hFile = (HANDLE)_wtoi64(argv[1]);

    const char* msg = "Hello from child process via parameter handle!\r\n";
    DWORD written;
    WriteFile(hFile, msg, (DWORD)strlen(msg), &written, NULL);

    std::cout << "å­è¿›ç¨‹å†™å…¥å®Œæˆ" << std::endl;
    return 0;
}
```

- çˆ¶è¿›ç¨‹æŠŠå¥æŸ„å€¼ä½œä¸ºå‘½ä»¤è¡Œå‚æ•°ä¼ é€’ï¼Œå­è¿›ç¨‹ç›´æ¥ä½¿ç”¨å¥æŸ„å†™å…¥æ–‡ä»¶ã€‚  

---

## æ€»ç»“

- **æ–¹æ³•ä¸€ï¼ˆç»§æ‰¿å¥æŸ„ï¼‰**ï¼šé™æ€æ–¹æ³•ï¼Œå­è¿›ç¨‹åˆ›å»ºæ—¶ç›´æ¥ç»§æ‰¿å¥æŸ„ï¼Œç®€å•ç›´æ¥ã€‚  
- **æ–¹æ³•äºŒï¼ˆåŠ¨æ€å¥æŸ„ä¼ é€’ï¼‰**  
  - **2a**ï¼šé€šè¿‡ `DuplicateHandle + CreateRemoteThread + å¯¼å‡ºå‡½æ•°`ï¼Œé€‚åˆå‘å·²æœ‰è¿›ç¨‹åŠ¨æ€ä¼ é€’å¥æŸ„å¹¶æ‰§è¡Œæ“ä½œã€‚  
  - **2b**ï¼šé€šè¿‡å‚æ•°ä¼ é€’å¥æŸ„ï¼Œçˆ¶å­è¿›ç¨‹ç›´æ¥å…±äº«èµ„æºï¼Œç®€å•æ˜“ç”¨ã€‚  

---

