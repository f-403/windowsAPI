# 带继承句柄的代码

```cpp
// 进程继承父进程的句柄.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <Windows.h>
#include <string>
int main()
{
    SECURITY_ATTRIBUTES sa{};
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = NULL;
    sa.nLength = sizeof(sa);
    HANDLE f = CreateFileA("1.TXT", GENERIC_ALL, 0, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    PROCESS_INFORMATION pf{};
    STARTUPINFO st{};
    st.cb = sizeof(st);
    std::wstring cmd = std::wstring(L"1.exe ") + std::to_wstring((uintptr_t)f);
    std::cout << "当前句柄值为:" << f << std::endl;
    int check = CreateProcess(NULL, &cmd[0], NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &st, &pf);
    if (check == FALSE) {
        std::cout << "调用失败" << std::endl;
        return 0;
    }
    //带W版本能传常量， A版本要用char []可修改的数组形式
    WaitForSingleObject(pf.hProcess, -1);


}
```

# 用于接收父进程的句柄

```cpp
#include <Windows.h>
#include <iostream>

int main(int argc, char* argv[]) {


    if (argc < 2) {
        std::cerr << "use: 程序.exe 句柄" << std::endl;
        system("pause");
        return 0;
    }
    //利用标准C函数读取参数
    char* check_char = nullptr;
    errno = 0;//初始化内置变量
    ULONGLONG get_ulonglong = strtoull(argv[1], &check_char, 0);
    //数字转指针再转为HANDLE
    HANDLE get_h = HANDLE( uintptr_t(get_ulonglong));

    if (errno == ERANGE) {
        std::cout << "转换出错" << std::endl;
        system("pause");
        return 0;
    }
    if (*check_char != '\0') {
        std::cout << "含有字符， 转换可能不正确" << std::endl;
        system("pause");
        return 0;
    }

    std::cout << "获取到的句柄为: " << std::hex << get_h<< std::endl;
    //写数据
    DWORD write_bytes{};
    WriteFile(get_h, u8"这是子进程写入的数据",strlen(u8"这是子进程写入的数据"),&write_bytes,NULL);//注意编码
    //strlen返回字节数， 不含9， 而sizeof含0
    //const wchar_t* wdata = L"这是子进程写入的数据";
    //DWORD bytesToWrite = (DWORD)(wcslen(wdata) * sizeof(wchar_t)); // 宽字符字节数
    //
    std::cout << "写入了:" << write_bytes << " 字节" << std::endl;

    system("pause");
    return 0;
}
```


# Windows 文件句柄传递方法说明

## 📑 目录
1. [概述](#概述)  
2. [方法一：句柄继承](#方法一句柄继承)  
   - [步骤](#步骤)  
   - [示例代码](#示例代码)  
3. [方法二：动态句柄传递](#方法二动态句柄传递)  
   - [方法 2a：DuplicateHandle + CreateRemoteThread + 导出函数](#方法-2a-duplicatehandle--createremotethread--导出函数)  
   - [方法 2b：父子进程参数传递句柄](#方法-2b-父子进程参数传递句柄)  
4. [总结](#总结)  

---

## 概述
在 Windows 下，父进程与子进程之间共享文件句柄的主要方法有两类：  

1. **继承句柄**（CreateProcess + bInheritHandles）  
2. **动态句柄传递**  
   - 方法 2a：通过 `DuplicateHandle + CreateRemoteThread` 在目标进程执行导出函数操作句柄  
   - 方法 2b：将句柄作为参数传递给子进程  

---

## 方法一：句柄继承

### 步骤

1. **创建可继承的文件句柄**
```cpp
SECURITY_ATTRIBUTES sa = {};
sa.nLength = sizeof(sa);
sa.bInheritHandle = TRUE;  // 允许子进程继承
sa.lpSecurityDescriptor = NULL;

HANDLE hFile = CreateFile(
    L"test.txt",
    GENERIC_WRITE,
    0,
    &sa,
    CREATE_ALWAYS,
    FILE_ATTRIBUTE_NORMAL,
    NULL
);
```

2. **配置 STARTUPINFO（标准 I/O）**
```cpp
STARTUPINFO si = {0};
si.cb = sizeof(si);
si.dwFlags = STARTF_USESTDHANDLES;
si.hStdOutput = hFile;
si.hStdError  = hFile;
si.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);
```

3. **创建子进程并继承句柄**
```cpp
PROCESS_INFORMATION pi = {};
BOOL ok = CreateProcess(
    L"child.exe",
    NULL,
    NULL, NULL,
    TRUE,   // bInheritHandles = TRUE
    0,
    NULL, NULL,
    &si, &pi
);
```

---

### 示例代码

#### 父进程
```cpp
#include <windows.h>
#include <iostream>

int main() {
    SECURITY_ATTRIBUTES sa = {};
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;

    HANDLE hFile = CreateFile(
        L"output.txt",
        GENERIC_WRITE,
        0,
        &sa,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    STARTUPINFO si = { sizeof(si) };
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdOutput = hFile;
    si.hStdError  = hFile;
    si.hStdInput  = GetStdHandle(STD_INPUT_HANDLE);

    PROCESS_INFORMATION pi = {};
    CreateProcess(L"child.exe", NULL, NULL, NULL,
                  TRUE, 0, NULL, NULL, &si, &pi);

    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(hFile);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    std::cout << "父进程完成" << std::endl;
}
```

#### 子进程
```cpp
#include <iostream>

int main() {
    std::cout << "Hello from child process via inherited handle!" << std::endl;
    return 0;
}
```

---



## 方法 2a：DuplicateHandle + CreateRemoteThread + 导出函数

#### 1️⃣ 子进程（child.exe）

```cpp
// child.cpp
#include <windows.h>
#include <iostream>

extern "C" __declspec(dllexport) DWORD WINAPI RemoteWrite(LPVOID lpParam) {
    HANDLE hFile = (HANDLE)lpParam;
    const char* msg = "Hello from RemoteWrite!\r\n";
    DWORD written;
    WriteFile(hFile, msg, (DWORD)strlen(msg), &written, NULL);
    std::cout << "子进程：RemoteWrite 已执行" << std::endl;
    return 0;
}

int main() {
    std::cout << "子进程启动，PID: " << GetCurrentProcessId() << std::endl;
    std::cout << "等待远程线程调用 RemoteWrite..." << std::endl;
    Sleep(60000); // 等待父进程调用
    return 0;
}
```

* 核心：导出 `RemoteWrite(HANDLE)`，父进程可以远程调用。

---

#### 2️⃣ 父进程

```cpp
#include <windows.h>
#include <iostream>
#include <tlhelp32.h>

// 辅助：通过模块名获取子进程中导出函数地址
LPVOID GetRemoteFuncAddress(DWORD pid, const wchar_t* moduleName, const char* funcName) {
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
    if (hSnap == INVALID_HANDLE_VALUE) return nullptr;

    MODULEENTRY32 me = {};
    me.dwSize = sizeof(me);
    if (Module32First(hSnap, &me)) {
        do {
            if (_wcsicmp(me.szModule, moduleName) == 0) {
                // 这里简化处理：假设子进程模块基址 + 偏移已知
                // 实际可用导出表解析或 DLL 注入方式获取
                LPVOID funcAddr = (LPBYTE)me.modBaseAddr + 0x1000; // 假设偏移
                CloseHandle(hSnap);
                return funcAddr;
            }
        } while (Module32Next(hSnap, &me));
    }

    CloseHandle(hSnap);
    return nullptr;
}

int main() {
    DWORD targetPid = 1234; // 替换为子进程 PID
    HANDLE hTarget = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);
    if (!hTarget) {
        std::cerr << "OpenProcess failed\n";
        return 1;
    }

    // 创建文件句柄
    HANDLE hFile = CreateFile(L"remote_output.txt",
                              GENERIC_WRITE, 0, NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    // 复制句柄到目标进程
    HANDLE hRemoteFile = NULL;
    DuplicateHandle(GetCurrentProcess(), hFile, hTarget, &hRemoteFile,
                    0, TRUE, DUPLICATE_SAME_ACCESS);

    // 获取子进程 RemoteWrite 地址
    LPTHREAD_START_ROUTINE remoteFunc = (LPTHREAD_START_ROUTINE)
        GetRemoteFuncAddress(targetPid, L"child.exe", "RemoteWrite");

    if (!remoteFunc) {
        std::cerr << "获取远程函数地址失败\n";
        CloseHandle(hRemoteFile);
        CloseHandle(hFile);
        CloseHandle(hTarget);
        return 1;
    }

    // 创建远程线程执行子进程导出函数
    HANDLE hThread = CreateRemoteThread(hTarget, NULL, 0,
                                        remoteFunc, hRemoteFile, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);
    CloseHandle(hRemoteFile);
    CloseHandle(hFile);
    CloseHandle(hTarget);

    std::cout << "父进程调用完成" << std::endl;
    return 0;
}
```

---

### 🔹 核心说明

1. **DuplicateHandle**

   * 父进程创建的文件句柄复制到子进程，远程线程可以直接使用。

2. **CreateRemoteThread**

   * 父进程在子进程创建线程，调用导出函数 `RemoteWrite`。

3. **获取子进程函数地址**

   * 示例中用 `Toolhelp32Snapshot` 遍历模块列表，得到模块基址，再加偏移（示例假设偏移已知）。
   * 实际生产环境可用 **导出表解析** 或 **DLL 注入** 获取函数地址。

---


## 方法 2b：父子进程参数传递句柄

#### 父进程
```cpp
#include <windows.h>
#include <iostream>
#include <sstream>

int main() {
    SECURITY_ATTRIBUTES sa = {};
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;

    HANDLE hFile = CreateFile(L"param_output.txt",
                              GENERIC_WRITE, 0, &sa,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    std::wstringstream cmdLine;
    cmdLine << L"child.exe " << (ULONG_PTR)hFile;

    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = {};

    CreateProcess(NULL,
                  (LPWSTR)cmdLine.str().c_str(),
                  NULL, NULL,
                  TRUE,   // bInheritHandles
                  0, NULL, NULL,
                  &si, &pi);

    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(hFile);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    std::cout << "父进程完成" << std::endl;
}
```

#### 子进程
```cpp
#include <windows.h>
#include <iostream>

int wmain(int argc, wchar_t* argv[]) {
    if (argc < 2) {
        std::wcerr << L"缺少句柄参数" << std::endl;
        return 1;
    }

    HANDLE hFile = (HANDLE)_wtoi64(argv[1]);

    const char* msg = "Hello from child process via parameter handle!\r\n";
    DWORD written;
    WriteFile(hFile, msg, (DWORD)strlen(msg), &written, NULL);

    std::cout << "子进程写入完成" << std::endl;
    return 0;
}
```

- 父进程把句柄值作为命令行参数传递，子进程直接使用句柄写入文件。  

---

## 总结

- **方法一（继承句柄）**：静态方法，子进程创建时直接继承句柄，简单直接。  
- **方法二（动态句柄传递）**  
  - **2a**：通过 `DuplicateHandle + CreateRemoteThread + 导出函数`，适合向已有进程动态传递句柄并执行操作。  
  - **2b**：通过参数传递句柄，父子进程直接共享资源，简单易用。  

---

