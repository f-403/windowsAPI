

# Windows API `CREATE_NEW_PROCESS_GROUP` 用法说明

## 📑 目录

1. [概述](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E6%A6%82%E8%BF%B0)

2. [作用](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E4%BD%9C%E7%94%A8)

3. [MSDN 参考](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#msdn-%E5%8F%82%E8%80%83)

4. [示例程序](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F)
   
   - [子进程：信号处理程序](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F)
   
   - [父进程：创建新进程组并发送信号](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%B9%B6%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7)

5. [运行效果](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C)

6. [注意事项](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)

7. [总结](https://chatgpt.com/c/68a44f83-d054-832c-8a07-dd3124965670#%E6%80%BB%E7%BB%93)

---

## 概述

在 Windows API 的 **`CreateProcess`** 中，可以通过 `dwCreationFlags` 指定进程创建选项。  
其中 **`CREATE_NEW_PROCESS_GROUP`** 用于让新进程成为一个独立的进程组根进程。

---

## 作用

1. 新进程成为新进程组的根进程（组 ID = 根进程 PID）。

2. 父进程和子进程不再共享控制台信号（如 `Ctrl+C`）。

3. 父进程可以通过 `GenerateConsoleCtrlEvent` 单独向该进程组发送控制台事件。

---

## MSDN 参考

- [Process Creation Flags - CREATE_NEW_PROCESS_GROUP](https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags#CREATE_NEW_PROCESS_GROUP)

---

## 示例程序

### 子进程：信号处理程序

编译成 `child.exe`，用于测试信号捕获：

```cpp
// child.cpp
#include <windows.h>
#include <iostream>

BOOL WINAPI ConsoleHandler(DWORD signal) {
    switch (signal) {
    case CTRL_C_EVENT:
        std::cout << "[子进程] 收到 CTRL+C 信号" << std::endl;
        return TRUE;  // 阻止默认退出行为
    case CTRL_BREAK_EVENT:
        std::cout << "[子进程] 收到 CTRL+BREAK 信号" << std::endl;
        return TRUE;
    default:
        return FALSE;
    }
}

int main() {
    SetConsoleCtrlHandler(ConsoleHandler, TRUE);

    std::cout << "[子进程] 已启动，PID=" << GetCurrentProcessId()
              << "，等待控制台信号..." << std::endl;

    while (true) {
        Sleep(1000);
    }
    return 0;
}
```

---

### 父进程：创建新进程组并发送信号

父进程创建 `child.exe`，指定 `CREATE_NEW_PROCESS_GROUP`，然后发送 `CTRL_BREAK_EVENT`：

```cpp
// parent.cpp
#include <windows.h>
#include <iostream>

int main() {
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;

    BOOL ok = CreateProcess(
        L"child.exe",   // 自定义子进程
        NULL,
        NULL, NULL,
        TRUE,  // 继承控制台，保证信号可路由
        CREATE_NEW_PROCESS_GROUP, // 关键标志
        NULL, NULL,
        &si, &pi);

    if (!ok) {
        std::cout << "CreateProcess failed: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "[父进程] 子进程 PID=" << pi.dwProcessId
              << " 已启动（独立进程组）" << std::endl;

    Sleep(3000);

    std::cout << "[父进程] 发送 CTRL_BREAK_EVENT 给子进程组..." << std::endl;
    GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, pi.dwProcessId);

    Sleep(3000);

    std::cout << "[父进程] 等待子进程退出 (Ctrl+Break 被拦截后仍在运行)" << std::endl;

    // 如果想终止子进程，可以手动结束
    TerminateProcess(pi.hProcess, 0);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return 0;
}
```

---

## 运行效果

1. 运行父进程 → 创建 `child.exe`，作为独立进程组。

2. 子进程打印：
   
   ```
   [子进程] 已启动，PID=1234，等待控制台信号...
   ```

3. 父进程调用 `GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, 子进程PID)`。

4. 子进程捕获并输出：
   
   ```
   [子进程] 收到 CTRL+BREAK 信号
   ```

5. 父进程不会退出，也不会收到信号。

---

## 注意事项

- `GenerateConsoleCtrlEvent` 必须在同一控制台内使用。

- `CTRL_C_EVENT` 在某些情况下可能被忽略，推荐用 `CTRL_BREAK_EVENT` 测试。

- GUI 程序不会响应控制台信号。

- 子进程必须是 **控制台子系统 (Console Subsystem)** 程序，否则信号不会传递。

---

## 总结

- `CREATE_NEW_PROCESS_GROUP` 让子进程独立于父进程的控制台信号管理。

- 父进程可用 `GenerateConsoleCtrlEvent` 单独控制子进程组。

- 配合 `SetConsoleCtrlHandler` 可以验证信号传播机制。

---


