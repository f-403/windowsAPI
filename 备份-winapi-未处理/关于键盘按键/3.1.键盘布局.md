# GetKeyboardState 与 ToUnicodeEx 必须配合使用，这是 Windows 键盘输入处理的标准流程
虚拟键: https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes

# 1. BOOL GetKeyboardState
> 初始化键盘数组
```
BOOL GetKeyboardState(
  [out] PBYTE lpKeyState
);
参数
[out] lpKeyState
类型： PBYTE
接收每个虚拟密钥的状态数据的 256 字节数组。
返回值
类型： BOOL
如果该函数成功，则返回值为非零值。
如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。
```
# 2. int ToUnicodeEx
> 将虚拟键码（Virtual Key Code） 转换为Unicode 字符的核心函数
```cpp
int ToUnicodeEx(
  [in]           UINT       wVirtKey,     // 虚拟键码（如 VK_A）
  [in]           UINT       wScanCode,    // 硬件扫描码（可忽略，填 0）
  [in]           const BYTE *lpKeyState,  // 键盘状态数组（256字节，记录每个键的按下/释放状态）
  [out]          LPWSTR     pwszBuff,     // 输出缓冲区（存储转换后的 Unicode 字符）
  [in]           int        cchBuff,      // 缓冲区大小（缓冲区大小（以 wchar_t 为单位）,一个字符就1， 2个就2）
  [in]           UINT       wFlags,       // 转换标志（如是否为死键）
  [in, optional] HKL        dwhkl         // 键盘布局句柄（指定输入法/键盘语言，NULL 表示当前布局）
);
//成功转换的 Unicode 字符数（可能为多字符，如死键组合）。
```
# 3. MapVirtualKey
```CPP
UINT MapVirtualKey(
  [in] UINT uCode,     // 输入的键码值
  [in] UINT uMapType   // 转换类型（指定如何转换）
);

// 1. 虚拟键码 → 扫描码
UINT scanCode = MapVirtualKey(VK_A, 0);  // 返回 A 键的扫描码（如 0x1E）
//2. 扫描码 → 虚拟键码
UINT vkCode = MapVirtualKey(0x1E, 1);  // 返回扫描码 0x1E 对应的虚拟键码（VK_A）
//3. 虚拟键码 → 简化字符码
// 获取 A 键对应的字符码（不考虑 Shift，仅根据 Caps Lock 状态）
UINT charCode = MapVirtualKey(VK_A, 2);  // 可能返回 0x41 ('A') 或 0x61 ('a')
//4. 虚拟键码 → Unicode 值
wchar_t unicodeChar = (wchar_t)MapVirtualKey(VK_A, 4);  // 返回 L'A' (0x0041)

//第二个参数说明:
| `uMapType` 值 | 转换方向                  | 核心逻辑                                                                 |
|---------------|--------------------------|--------------------------------------------------------------------------|
| 0           | 虚拟键码 → 扫描码         | 将虚拟键码（如 `VK_A`）转换为硬件扫描码（键盘特定的编码，如 `0x1E`）。           |
| 1           | 扫描码 → 虚拟键码         | 将扫描码转换回虚拟键码。                                                   |
| 2           | 虚拟键码 → 未转换的字符码 | 将虚拟键码转换为对应的 ASCII 或 ANSI 字符码（仅考虑 Caps Lock，忽略 Shift）。 |
| 3           | 扫描码 → 扩展虚拟键码     | 处理扩展键（如右 Ctrl、NumPad 键），返回带扩展标志的虚拟键码。               |
| 4           | 虚拟键码 → Unicode 字符值 | 将虚拟键码转换为对应的 Unicode 码点（如 `VK_A` → `U+0041`）。               |
| 5           | 虚拟键码 → 未转换的 Unicode | 类似 4，但不处理死键组合（如 `^` + `e` → `ê`）。                        |
```
## 例子1 

```cpp
BYTE keyboardState[256];                  // 1. 创建键盘状态数组
GetKeyboardState(keyboardState);          // 2. 获取当前所有键的状态（包括Shift/Ctrl等修饰键）

wchar_t unicodeChar = 0;                 // 3. 准备接收Unicode字符
int result = ToUnicodeEx(
    vkCode,                              // 虚拟键码（如VK_A）
    scanCode,                            // 硬件扫描码
    keyboardState,                       // 传入键盘状态数组
    &unicodeChar,                        // 输出Unicode字符
    1,                                   // 缓冲区大小（1个字符）
    0,                                   // 标志位（通常为0）
    GetKeyboardLayout(0)                 // 当前键盘布局
);
```
## 例子2

```cpp
#include <Windows.h>
#include <iostream>

int main() {
    // 模拟按下 'A' 键
    UINT vkCode = 'A';
    UINT scanCode = MapVirtualKey(vkCode, MAPVK_VK_TO_VSC);

    // 1. 获取键盘状态（必须！）
    BYTE keyboardState[256];
    GetKeyboardState(keyboardState);

    // 2. 转换为Unicode字符
    wchar_t unicodeChar = 0;
    int result = ToUnicodeEx(
        vkCode,
        scanCode,
        keyboardState,
        &unicodeChar,  // 输出缓冲区
        1,             // 缓冲区大小
        0,             // 标志位
        GetKeyboardLayout(0)  // 当前键盘布局
    );

    // 3. 处理结果
    if (result > 0) {
        std::wcout << L"转换结果: " << unicodeChar << std::endl;
    } else if (result == 0) {
        std::cout << "无对应字符（可能是功能键）" << std::endl;
    } else {
        std::cout << "死键状态（需二次输入）" << std::endl;
        /*
        在 Windows 编程中，ToUnicodeEx 函数用于将指定的虚拟键代码和键盘状态转换为相应的 Unicode 字符。ToUnicodeEx 获取到的死键是指生成诸如变音符号（如 umlaut（双点）、 acute accent（尖音符）等）的键，这些符号通常与其他字符结合使用以形成复合字符。
        例如，要生成带 umlaut 的 Ö 字符，可能需要先键入表示 umlaut 的死键，然后再键入 O 键。当 ToUnicodeEx 函数遇到死键对应的虚拟键代码时，它会根据键盘状态和其他参数来确定如何将其转换为 Unicode 字符。如果函数返回值小于 0，就表示指定的虚拟键是一个死键字符。
        在处理死键时，ToUnicodeEx 函数会尝试将死键字符的间距版本写入到指定的缓冲区中。例如，对于 acute accent 字符，函数可能会写入 U+00B4（SPACING ACUTE ACCENT），而不是 U+0301（COMBINING ACUTE ACCENT）。
        
        
        */
    }

    return 0;
}
```